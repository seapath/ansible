# Copyright (C) 2024, RTE (http://www.rte-france.com)
# SPDX-License-Identifier: Apache-2.0

---
- name: Query if current node is in Pacemaker standby
  ansible.builtin.command:
    cmd: crm_attribute --node {{ inventory_hostname }} --name standby -q
  register: deploy_vms_cluster_standby_check
  changed_when: false
  failed_when: false

- name: Fail if current node is in Pacemaker standby
  ansible.builtin.fail:
    msg: >-
      Node '{{ inventory_hostname }}' is in Pacemaker standby mode.
      Cannot deploy VM '{{ item }}' on a standby node.
      Bring the node online first: crm node online {{ inventory_hostname }}
  when:
    - deploy_vms_cluster_standby_check.stdout is defined
    - "'on' == deploy_vms_cluster_standby_check.stdout"

- name: Query if current node is in Pacemaker maintenance
  ansible.builtin.command:
    cmd: crm_attribute --node {{ inventory_hostname }} --name maintenance -q
  register: deploy_vms_cluster_maintenance_check
  changed_when: false
  failed_when: false

- name: Fail if current node is in Pacemaker maintenance
  ansible.builtin.fail:
    msg: >-
      Node '{{ inventory_hostname }}' is in Pacemaker maintenance mode.
      Cannot deploy VM '{{ item }}' on this node.
      Bring the node online first: crm_attribute --node {{ inventory_hostname }} --name maintenance --delete
  when:
    - deploy_vms_cluster_maintenance_check.stdout is defined
    - "'true' == deploy_vms_cluster_maintenance_check.stdout"

- name: Check presence of vm before copy
  cluster_vm:
    command: status
    name: "{{ item }}"
  register: deploy_vms_cluster_presencevm
- debug:
    var: deploy_vms_cluster_presencevm
    verbosity: 2

- name: Check tmp folder permission
  file:
    path: "{{ deploy_vms_cluster_qcow2tmpuploadfolder }}"
    state: directory
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    mode: '0755'
  when:
    - deploy_vms_cluster_qcow2tmpuploadfolder is defined
    - deploy_vms_cluster_qcow2tmpuploadfolder != "/tmp"

- when: deploy_vms_cluster_presencevm.status == "Undefined" or (hostvars[item].force is defined and hostvars[item].force)
  vars:
    vm_file: "{{ hostvars[item].vm_disk | default( deploy_vms_cluster_vms_disks_directory ~ '/' ~ item ~ '.qcow2') }}"
    vm_file_dest: "{{ deploy_vms_cluster_qcow2tmpuploadfolder + '/os.qcow2' }}"
  block:
    - name: "Copy system disk on target for {{ item }}"
      copy:
        src: "{{ vm_file }}"
        dest: "{{ vm_file_dest }}"
      vars:
        ansible_remote_tmp: "{{ deploy_vms_cluster_qcow2tmpuploadfolder | default(omit) }}"
      when: deploy_vms_cluster_disk_copy | bool
    - name: "Create {{ item }}"
      cluster_vm:
        name: "{{ item }}"
        command: create
        system_image: "{{ vm_file_dest }}"
        force: true
        live_migration: "{{ hostvars[item].live_migration | default(false) }}"
        migration_user: "{{ livemigration_user | default(omit) }}"
        migrate_to_timeout: "{{ hostvars[item].migrate_to_timeout | default(omit) }}"
        migration_downtime: "{{ hostvars[item].migration_downtime | default(omit) }}"
        priority: "{{ hostvars[item].priority | default(omit) }}"
        enable: "{{ hostvars[item].enable | default(true) }}"
        nostart: "{{ hostvars[item].nostart | default(false) }}"
        pinned_host: "{{ hostvars[item].pinned_host | default(omit) }}"
        preferred_host: "{{ hostvars[item].preferred_host | default(omit) }}"
        crm_config_cmd: "{{ hostvars[item].crm_config_cmd | default(omit) }}"
        xml: >-
          {{ lookup('file', hostvars[item].xml_path)
               if hostvars[item].xml_path is defined
             else lookup('template',hostvars[item].vm_template,template_vars=dict(vm=hostvars[item]))
               if hostvars[item].vm_template is defined
             else lookup('file',deploy_vms_cluster_vms_disks_directory + '/' + item + '.xml')
             | replace('\n', '') }}
    - name: Remove temporary file
      file:
        path: "{{ vm_file_dest }}"
        state: absent
    - name: Wait for VM connections
      wait_for_connection:
      delegate_to: "{{ item }}"
      when:
        - hostvars[item].wait_for_connection is defined
        - hostvars[item].wait_for_connection

- name: "Define colocation constraints for {{ item }}"
  cluster_vm:
    name: "{{ item }}"
    command: define_colocation
    strong: "{{ hostvars[item].strong_colocation | default(false) }}"
    colocated_vms: "{{ hostvars[item].colocated_vms }}"
  when: hostvars[item].colocated_vms is defined
