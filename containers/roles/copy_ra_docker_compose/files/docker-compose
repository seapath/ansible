#!/bin/sh
# Version: 1.1.2
# Date: 2020-06-24
#
# Resource script for running docker-compose
#
# Description:  Manages docker services using docker-compose as an OCF
#               resource in an High Availability setup.
#               It relies on a well-tested docker-compose YAML file which
#               distributed on an identical location on all cluster nodes.
#
# Caveat: 1. A YAML file (docker-compose.yml) and an optional Dockerfile
#            must be provided in a working directory.
#         2. It is suggested to test run the docker-compose and verify
#            on all cluster nodes before enabling this agent.

##Based on : https://github.com/ClusterLabs/resource-agents/heartbeat/docker-compose of:
# docker-compose OCF script's Author: Kenny Chen <netman@study-area.org>
# License: GNU General Public License (GPL)
#
#	usage: $0 {start|stop|status|monitor|validate-all|meta-data}
#
#	The "start" arg starts docker service.
#	The "stop" arg stops it.
#
# OCF parameters:
# OCF_RESKEY_binpath
# OCF_RESKEY_dirpath
# OCF_RESKEY_ymlfile
# OCF_RESKEY_rbdpool
# OCF_RESKEY_rbdimage
# OCF_RESKEY_mountpoint
# $SERVICE_NAME
##########################################################################
# Initialization:

: ${OCF_ROOT:=/usr/lib/ocf}
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

# Defaults
#OCF_RESKEY_binpath_default=/usr/bin/docker-compose
#OCF_RESKEY_ymlfile_default=docker-compose.yml
#: ${OCF_RESKEY_binpath=${OCF_RESKEY_binpath_default}}
#: ${OCF_RESKEY_ymlfile=${OCF_RESKEY_ymlfile_default}}

USAGE="Usage: $0 {start|stop|status|monitor|validate-all|meta-data}"

##########################################################################

usage()
{
	echo $USAGE >&2
}

meta_data()
{
cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="docker-compose" version="1.0.3">
<version>1.0</version>
<longdesc lang="en">
Manages docker services using docker-compose as an OCF resource in an High Availability setup.
It relies on a well-tested docker-compose YAML file which distributed on an identical location on all cluster nodes.

Caveat: 1. A YAML file (docker-compose.yml) and an optional Dockerfile
           must be provided in a working directory.
        2. It is suggested to test run the docker-compose and verify on all cluster nodes
           before enabling this agent.
</longdesc>
<shortdesc lang="en">This script manages docker services using docker-compose.</shortdesc>

<parameters>

<parameter name="name">
<longdesc lang="en">
The docker resource name.
For example, "my_docker_service"
</longdesc>
<shortdesc lang="en">The docker resource name</shortdesc>
<content type="string"/>
</parameter>

<parameter name="ymlfile">
<longdesc lang="en">
The docker-compose yaml file.
For example, "docker-compose.yml"
</longdesc>
<shortdesc lang="en">The docker-compose yaml</shortdesc>
<content type="string" default="$OCF_RESKEY_ymlfile_default"/>
</parameter>


</parameters>

<actions>
<action name="start" timeout="200s"/>
<action name="stop" timeout="20s"/>
<action name="monitor" depth="0" timeout="10s" interval="60s" />
<action name="validate-all" timeout="5s" />
<action name="meta-data"  timeout="5s"/>
</actions>
</resource-agent>
END
exit $OCF_SUCCESS
}
# use of the existing pool
#RBD_POOL="rbd"

SERVICE_NAME="$OCF_RESKEY_name"
RBD_VOLUME=""
YML="$OCF_RESKEY_ymlfile"
MOUNT_POINT="/opt/${SERVICE_NAME}"
#DEVICENAME=$(rbd showmapped | awk -v img="${OCF_RESKEY_name}" '$3 == img {print $5}' | head -n1)

docker_kill()
{
	for i in $(docker ps --all | awk -e '$NF ~ /\<'"${PRE}"'_.*_[0-9]+\>/ {print $1}'); do
		docker kill $i >/dev/null 2>&1
		docker rm $i >/dev/null 2>&1 || RTV=false
	done
	if [ "$RTV" = false ]; then
		ocf_log err "failed to kill docker"
		return $OCF_ERR_GENERIC
	else
		RUN=false
	fi
}

docker_compose_status()
{
	# use docker-compose ps if YML found, otherwise try docker ps and kill containers
	if [ -r "$MOUNT_POINT/$YML" ]; then
		DKPS=$(docker-compose -f "$MOUNT_POINT/$YML" ps -q)

		# get number of all containers
		[ -n "$DKPS" ] && PSNU=$(echo "$DKPS" | wc -l)
		# get number of running containers
		for UUID in $DKPS; do
			UP=$(docker inspect --format='{{.State.Running}}' "$UUID")
			[ "$UP" = "true" ] && UPNU=$((UPNU+1))
		done

		if [ "${PSNU:-0}" -ne 0 ]; then
			if [ ${UPNU:-0} -eq 0 ]; then
				ocf_log info "docker service is running but not in up state."
				return $OCF_NOT_RUNNING
			elif [ "$PSNU" -eq $UPNU ]; then
				ocf_log info "docker service is up and running"
				return $OCF_SUCCESS
			else
				ocf_log err "docker service is running with partial up state"
				return $OCF_ERR_GENERIC
			fi
		else
			RUN=false
		fi
	else
		STAT_MSG=$(docker ps --all | awk -e '$NF ~ /\<'"$PRE"'_.*_[0-9]+\>/ {print $1}')
		if [ -z "$STAT_MSG" ]; then
			RUN=false
		else
			ocf_log log "docker service is running without docker-compose, try to kill..."
			docker_kill
		fi
	fi
	[ "$RUN" = false ] && {
		ocf_log info "docker service is not running"
		return $OCF_NOT_RUNNING
	}
}

# Steps:
#   1. Validate Docker Compose configuration.
#   2. Check if the service is already running.
#   3. Create and format the RBD image if it does not exist.
#   4. Map the RBD image and mount it to the target directory.
#   5. Start the Docker Compose stack in detached mode.
docker_compose_start(){

  #docker_compose_validate_all
  docker_compose_status >/dev/null 2>&1
  retVal=$?
  ocf_log info "Docker status returned $retVal"
  # return success if docker service is running
  [ $retVal -eq $OCF_SUCCESS ] && exit $OCF_SUCCESS

  ocf_log info "Starting docker service $SERVICE_NAME..."

	docker_compose_up_with_create_volumes|| {
	  ocf_log err "Error. docker-compose returned error $?."
	  exit $OCF_ERR_GENERIC
	}
  ocf_log info "docker service started."
  exit $OCF_SUCCESS
}


docker_compose_stop() {
  #if mountpoint -q "$MOUNT_POINT"; then
    FILE="$MOUNT_POINT/$YML"
	ocf_log info "Stopping docker service $SERVICE_NAME..."
    if [ ! -f "$FILE" ]; then
      ocf_log err "YAML file $FILE does not exist."
      return $OCF_ERR_GENERIC
    fi
    docker-compose -f "$FILE" down -t 30 || {
      ocf_log err "Error on shutting down docker service, trying to kill..."
      RUN_KILL=true
    }
 # fi

  #umount "$MOUNT_POINT" || {
    #ocf_warn "Could not unmount $MOUNT_POINT"
   # return $OCF_ERR_GENERIC
  #}
  docker_compose_unmap
  ocf_log info "Docker service $SERVICE_NAME stopped."
  exit $OCF_SUCCESS
}

docker_compose_monitor()
{
	docker_compose_status
	ocf_log info "Docker monitor returned $?."
}

docker_compose_unmap()
{
  # Unmap the RBD device associated with the docker service
  # This is useful for cleaning up after the service is stopped.
  MAPS=$(rbd showmapped --format json | \
    jq -r --arg pool rbd --arg name "$SERVICENAME" \
      '.[] | select(.pool==$pool and .name==$name) | .device')
  COUNT=0
  for DEV in $MAPS; do
    if [ $COUNT -eq 0 ]; then
      COUNT=$((COUNT+1))
    else
      echo "Unmapping $DEV"
      rbd unmap "$DEV"
    fi
  done
}

docker_compose_validate_all()
{
	check_binary "$OCF_RESKEY_binpath" || {
    ocf_log err "Missing Docker binary: $OCF_RESKEY_binpath"
    exit $OCF_ERR_INSTALLED
  }

  if [ ! -d "$OCF_RESKEY_dirpath" ]; then
    ocf_log err "Working directory $OCF_RESKEY_dirpath is invalid."
    exit $OCF_ERR_ARGS
  fi

  if [ -z "$OCF_RESKEY_image_name" ]; then
    ocf_log err "Docker image name must be specified."
    exit $OCF_ERR_ARGS
  fi

  if [ -z "$OCF_RESKEY_name" ]; then
    ocf_log err "Service name must be provided."
    exit $OCF_ERR_ARGS
  fi

  return $OCF_SUCCESS
}
docker_compose_up_with_create_volumes() {
  COMPOSE_FILE="$MOUNT_POINT/$YML"
  OVERRIDE_FILE="$MOUNT_POINT/docker-compose.override.yml"

  # override file header
  {
    echo "version: '3.9'"
    echo "volumes:"
  } > "$OVERRIDE_FILE"

  ocf_log info "Vérification/Création des volumes pour $COMPOSE_FILE"

  # Parcourir les volumes définis
  for vname in $(yq e '.volumes | keys | .[]' "$COMPOSE_FILE" 2>/dev/null || true); do
    external=$(yq e ".volumes.$vname.external" "$COMPOSE_FILE")
    driver=$(yq e ".volumes.$vname.driver" "$COMPOSE_FILE")

    if [ "$external" = "true" ]; then
      ocf_log info "Volume $vname déjà external"
      {
        echo "  $vname:"
        echo "    external: true"
      } >> "$OVERRIDE_FILE"
      continue
    fi

    if [ "$driver" = "null" ] || [ -z "$driver" ]; then
      ocf_log info "Volume $vname sans driver (ignoré)"
      continue
    fi

    # Construire la commande de création
    cmd="docker volume create --driver $driver --name $vname"

    # Ajouter les driver_opts s'ils existent
    for opt in $(yq e ".volumes.$vname.driver_opts | keys | .[]" "$COMPOSE_FILE" 2>/dev/null || true); do
      val=$(yq e ".volumes.$vname.driver_opts.$opt" "$COMPOSE_FILE")
      cmd="$cmd --opt $opt=$val"
    done

    ocf_log info "Création du volume $vname avec $driver"
    if ! eval "$cmd"; then
      ocf_log warn "Volume $vname existe déjà ou création échouée"
    fi

    # Ajouter external dans override
    {
      echo "  $vname:"
      echo "    external: true"
    } >> "$OVERRIDE_FILE"
  done

  ocf_log info "Fichier override généré: $OVERRIDE_FILE"

  # Lancer docker-compose
  if ! docker-compose -f "$COMPOSE_FILE" -f "$OVERRIDE_FILE" up -d; then
    ocf_log err "docker-compose a échoué"
    exit $OCF_ERR_GENERIC
  fi

  ocf_log info "docker-compose exécuté avec succès"
  exit $OCF_SUCCESS
}


#
# Main
#

if [ $# -ne 1 ]; then
	usage
	exit $OCF_ERR_ARGS
fi

case $1 in
	start)
		docker_compose_start
		;;

	stop)
		docker_compose_stop
		;;

	status)
		docker_compose_status
		;;

	monitor)
		docker_compose_monitor
		;;

	validate-all)
		docker_compose_validate_all
		;;

	meta-data)
		meta_data
		;;

	usage)	usage
		exit $OCF_SUCCESS
		;;

	*)	usage
		exit $OCF_ERR_UNIMPLEMENTED
		;;
esac